package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/golang-jwt/jwt/v4"
	"github.com/vulnerability-shop/vulnerability-shop/user/utils"
)

type RegisterCredentials struct {
	Username    string `json:"username"`
	Password    string `json:"password"`
	Email       string `json:"email"`
	FirstName   string `json:"firstName"`
	LastName    string `json:"lastName"`
	Address     string `json:"address"`
	PhoneNumber string `json:"phoneNumber"`
}

type LoginCredentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type JwtClaims struct {
	Username string `json:"username"`
	jwt.RegisteredClaims
}

type User struct {
	Id          int
	Username    string
	Password    string
	Email       string
	FirstName   string
	LastName    string
	Address     string
	PhoneNumber string
	Role        int
}

type ContextUsername struct{}

var jwtSecret = []byte("secret") // Bad practice: We use a weak secret key

func Login(w http.ResponseWriter, r *http.Request) {
	var inputCredentials LoginCredentials

	err := json.NewDecoder(r.Body).Decode(&inputCredentials)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Vulnerability: SQL Injection
	query := fmt.Sprintf("SELECT * FROM Customer WHERE username = '%s' AND password='%s'",
		inputCredentials.Username, inputCredentials.Password)

	// Query the database to check if the username and password combination is valid.
	rows, err := utils.DB.Query(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Vulnerability : If we find any combination of username and password that match, we authorize the connection.
	// We are trusting the username entered by the user and we do not validate the password, so we could connect to any account using SQL injection
	if !rows.Next() {
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte("Username and password combination invalid."))
		return
	}

	// Make a new claims with a custom expiration
	expiration := time.Now().Add(24 * time.Hour)
	claims := &JwtClaims{
		Username: inputCredentials.Username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiration),
		},
	}

	// Create a new token signed with our secret
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   tokenString,
		Expires: expiration,
	})

	w.Write([]byte(fmt.Sprintf("Token: %s\nExpiration: %s", tokenString, expiration.String())))
}

func Register(w http.ResponseWriter, r *http.Request) {
	var inputCredentials RegisterCredentials

	err := json.NewDecoder(r.Body).Decode(&inputCredentials)
	// Validate that all the information required was sent to us
	if err != nil || len(inputCredentials.Username) == 0 || len(inputCredentials.Password) == 0 || len(inputCredentials.Password) == 0 ||
		len(inputCredentials.Email) == 0 || len(inputCredentials.FirstName) == 0 || len(inputCredentials.LastName) == 0 ||
		len(inputCredentials.PhoneNumber) == 0 || len(inputCredentials.Address) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Vulnerability: SQL injection
	query := fmt.Sprintf("SELECT * FROM Customer WHERE username = '%s'", inputCredentials.Username)

	// Query the database for any account that already uses the username
	rows, err := utils.DB.Query(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// If we find any rows, the account already exists
	if rows.Next() {
		w.WriteHeader(http.StatusConflict)
		w.Write([]byte("Username is already taken."))
		return
	}

	// Vulnerabilities: SQL injection and password not encrypted
	query = fmt.Sprintf("INSERT INTO Customer (email,username,password,"+
		"firstName,lastName,address,phoneNumber,user_role) VALUES ('%s','%s','%s','%s','%s','%s','%s', 1)",
		inputCredentials.Email, inputCredentials.Username, inputCredentials.Password, inputCredentials.FirstName,
		inputCredentials.LastName, inputCredentials.Address, inputCredentials.PhoneNumber)

	// Add the user to the database
	_, err = utils.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write([]byte("Account successfully created."))
}

func Logout(w http.ResponseWriter, r *http.Request) {
	// Set an expired cookie with an empty value
	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   "",
		Expires: time.Unix(0, 0),
	})
}

func ValidateTokenMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cookie, err := r.Cookie("token")
		if err != nil {
			ctx := context.WithValue(r.Context(), ContextUsername{}, "")
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		tokenString := cookie.Value
		claims := &JwtClaims{}

		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			return jwtSecret, nil
		})
		if err != nil || !token.Valid {
			ctx := context.WithValue(r.Context(), ContextUsername{}, "")
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// If the token is valid, we serve the request with the username in the context
		ctx := context.WithValue(r.Context(), ContextUsername{}, claims.Username)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
