package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/render"
	"github.com/golang-jwt/jwt/v4"
	"github.com/jackc/pgx/v5"
	"github.com/vulnerability-shop/vulnerability-shop/user/utils"
)

type RegisterCredentials struct {
	Username    string `json:"username"`
	Password    string `json:"password"`
	Email       string `json:"email"`
	FirstName   string `json:"firstName"`
	LastName    string `json:"lastName"`
	Address     string `json:"address"`
	PhoneNumber string `json:"phoneNumber"`
}

type LoginCredentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type LoginResponse struct {
	Username   string `json:"username"`
	Token      string `json:"token"`
	Expiration string `json:"expiration"`
}

type JwtClaims struct {
	UserId int `json:"userId"`
	jwt.RegisteredClaims
}

type UserContext struct{}

var jwtSecret = []byte("secret") // Bad practice: We use a weak secret key

func Login(w http.ResponseWriter, r *http.Request) {
	var inputCredentials LoginCredentials
	var userId int
	var username string

	err := json.NewDecoder(r.Body).Decode(&inputCredentials)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Vulnerability: SQL Injection
	query := fmt.Sprintf("SELECT id, username FROM Customer WHERE username = '%s' AND password='%s'",
		inputCredentials.Username, inputCredentials.Password)

	// Vulnerability : If we find any combination of username and password that match, we authorize the connection.
	// We do not directly validate the password, so we could connect to any account using SQL injection
	err = utils.DB.QueryRow(context.Background(), query).Scan(&userId, &username)
	if err != nil {
		if err == pgx.ErrNoRows {
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte("Username and password combination invalid."))
			return
		} else {
			fmt.Printf("Database query failed: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	// Make a new claims with a custom expiration
	expiration := time.Now().Add(24 * time.Hour)
	claims := &JwtClaims{
		UserId: userId,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiration),
		},
	}

	// Create a new token signed with our secret
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   tokenString,
		Expires: expiration,
	})

	render.JSON(w, r, &LoginResponse{
		Username:   username,
		Token:      tokenString,
		Expiration: expiration.String(),
	})
}

func Register(w http.ResponseWriter, r *http.Request) {
	var inputCredentials RegisterCredentials

	err := json.NewDecoder(r.Body).Decode(&inputCredentials)
	// Validate that all the information required was sent to us
	if err != nil || len(inputCredentials.Username) == 0 || len(inputCredentials.Password) == 0 || len(inputCredentials.Password) == 0 ||
		len(inputCredentials.Email) == 0 || len(inputCredentials.FirstName) == 0 || len(inputCredentials.LastName) == 0 ||
		len(inputCredentials.PhoneNumber) == 0 || len(inputCredentials.Address) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Vulnerability: SQL injection
	query := fmt.Sprintf("SELECT * FROM Customer WHERE username = '%s'", inputCredentials.Username)

	// Query the database for any account that already uses the username
	rows, err := utils.DB.Query(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	defer rows.Close()

	// If we find any rows, the account already exists
	if rows.Next() {
		w.WriteHeader(http.StatusConflict)
		w.Write([]byte("Username is already taken."))
		return
	}

	// Vulnerabilities: SQL injection and password not encrypted
	query = fmt.Sprintf("INSERT INTO Customer (email,username,password,"+
		"firstName,lastName,address,phoneNumber,user_role) VALUES ('%s','%s','%s','%s','%s','%s','%s', 1)",
		inputCredentials.Email, inputCredentials.Username, inputCredentials.Password, inputCredentials.FirstName,
		inputCredentials.LastName, inputCredentials.Address, inputCredentials.PhoneNumber)

	// Add the user to the database
	_, err = utils.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write([]byte("Account successfully created."))
}

func Logout(w http.ResponseWriter, r *http.Request) {
	// Set an expired cookie with an empty value
	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   "",
		Expires: time.Unix(0, 0),
	})
}

func ValidateToken(w http.ResponseWriter, r *http.Request) {
	cookie, err := r.Cookie("token")
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(err.Error()))
		return
	}

	userId := getUserIdFromToken(cookie.Value)
	if userId == -1 {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte(strconv.Itoa(userId)))
}

func getUserIdFromToken(tokenString string) int {
	userId := -1

	claims := &JwtClaims{}

	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})
	if err != nil || !token.Valid {
		return -1
	}

	userId = claims.UserId

	return userId
}

func ValidateTokenMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cookie, err := r.Cookie("token")
		if err != nil {
			ctx := context.WithValue(r.Context(), UserContext{}, -1)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		userId := getUserIdFromToken(cookie.Value)
		if userId == -1 {
			ctx := context.WithValue(r.Context(), UserContext{}, -1)
			next.ServeHTTP(w, r.WithContext(ctx))
			return
		}

		// If the token is valid, we serve the request with the user id in the context
		ctx := context.WithValue(r.Context(), UserContext{}, userId)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
