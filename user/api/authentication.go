package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/golang-jwt/jwt/v4"
)

type UserCredentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type JwtClaims struct {
	Username string `json:"username"`
	jwt.RegisteredClaims
}

var jwtSecret = []byte("secret") // We use a weak secret key

// TODO: Remove this and store users in DB instead
var users = map[string]string{
	"user1": "password1",
	"user2": "password2",
}

func Login(w http.ResponseWriter, r *http.Request) {
	var inputCredentials UserCredentials

	err := json.NewDecoder(r.Body).Decode(&inputCredentials)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	//TODO: Remove this and check users from DB instead
	expectedPassword, ok := users[inputCredentials.Username]

	// Check if the username is valid
	if !ok {
		// Bad practice: We intentionally tell the user that the username does not exist instead of giving a more generic error
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(fmt.Sprintf("User '%s' does not exist", inputCredentials.Username)))
		return
	}

	// Check if the password is valid
	if inputCredentials.Password != expectedPassword {
		// Bad practice: We intentionally tell the user the password is invalid instead of giving a more generic error
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte("Invalid password"))
		return
	}

	//Make a new claims with a custom expiration
	expiration := time.Now().Add(24 * time.Hour)
	claims := &JwtClaims{
		Username: inputCredentials.Username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiration),
		},
	}

	//Create a new token signed with our secret
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//TODO: Create a cookie
	w.Write([]byte(fmt.Sprintf("Token: %s\nExpiration: %s", tokenString, expiration.String())))
}
