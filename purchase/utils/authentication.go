package utils

// import (
// 	"context"
// 	"encoding/json"
// 	"fmt"
// 	"net/http"
// 	"time"

// 	"github.com/go-chi/render"
// 	"github.com/golang-jwt/jwt/v4"
// 	"github.com/jackc/pgx/v5"
// 	"github.com/vulnerability-shop/vulnerability-shop/user/utils"
// )

// type JwtClaims struct {
// 	UserId int `json:"userId"`
// 	jwt.RegisteredClaims
// }

// type UserContext struct{}

// var jwtSecret = []byte("secret") // Bad practice: We use a weak secret key

// func ValidateTokenMiddleware(next http.Handler) http.Handler {
// 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
// 		cookie, err := r.Cookie("token")
// 		if err != nil {
// 			ctx := context.WithValue(r.Context(), UserContext{}, -1)
// 			next.ServeHTTP(w, r.WithContext(ctx))
// 			return
// 		}

// 		tokenString := cookie.Value
// 		claims := &JwtClaims{}

// 		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
// 			return jwtSecret, nil
// 		})
// 		if err != nil || !token.Valid {
// 			ctx := context.WithValue(r.Context(), UserContext{}, -1)
// 			next.ServeHTTP(w, r.WithContext(ctx))
// 			return
// 		}

// 		// If the token is valid, we serve the request with the user id in the context
// 		ctx := context.WithValue(r.Context(), UserContext{}, claims.UserId)
// 		next.ServeHTTP(w, r.WithContext(ctx))
// 	})
// }
