package api

import (
	"context"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/render"
	"github.com/jackc/pgx/v5"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/models"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/utils"
)

type PurchaseOrder struct {
	CustomerId int
	PaymentId  int
	Items      []models.CartItemDto
}

func GetPurchases(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func GetPurchaseById(w http.ResponseWriter, r *http.Request) {
	var purchase models.Purchase

	id := r.URL.Query().Get("id")
	if id == "" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	err := utils.DB.QueryRow(context.Background(), "SELECT * FROM purchase WHERE id=$1",
		id).Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchase)
}

func GetPurchasesForUser(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase
	var id int = r.Context().Value(utils.UserContext{}).(int)
	if id == -1 {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase WHERE customer_id=$1")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func AddPurchase(w http.ResponseWriter, r *http.Request) {
	var purchase PurchaseOrder
	var tx pgx.Tx
	var err error

	//Check if user is logged in
	userId, err := strconv.Atoi(r.Context().Value(utils.UserContext{}).(string))
	if userId == -1 || err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	purchase.CustomerId = userId

	//TODO check payment exists --> Payment not yet implemented ignore for now
	purchase.PaymentId = 1

	//fetch items from cart
	purchase.Items, err = utils.FetchCartItems(r.Header.Get("Authorization"))
	if err != nil {
		fmt.Printf("Error fetching cart items: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//Begin transaction
	tx, err = utils.DB.BeginTx(context.Background(), pgx.TxOptions{})
	if err != nil {
		fmt.Printf("Error starting transaction: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//Fetch items to calculate price and update inventory
	var cost float32
	for _, purchaseItem := range purchase.Items {
		item, err := utils.FetchItem(purchaseItem.ItemId)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if item.Id == 0 || purchaseItem.ItemQuantity <= 0 {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		if item.Stock < purchaseItem.ItemQuantity {
			//Not enough in stock
			fmt.Print("Not enough stock")
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		//Add price to order and update stock
		cost += item.Price
		err = utils.OrderItem(purchaseItem.ItemId, purchaseItem.ItemQuantity)
		if err != nil {
			tx.Rollback(context.Background())
			fmt.Printf("Error updating inventory: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	// Add the purchase to the database
	// Vulnerabilities: SQL injection
	now := time.Now().UTC()
	var query = fmt.Sprintf("INSERT INTO purchase(customer_id, payment_id, purchase_cost, purchase_date) VALUES ('%d','%d','%f','%v') RETURNING id",
		purchase.CustomerId, purchase.PaymentId, cost, now.Format("2006-01-02T15:04:05Z"))
	// The Id of the created purchase
	var id int = 0
	err = utils.DB.QueryRow(context.Background(), query).Scan(&id)
	if err != nil {
		tx.Rollback(context.Background())
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Add all items to purchaseItem @/item/addPurchaseItem, if unsuccessful, cancel purchase
	for _, item := range purchase.Items {
		var purchaseItem models.PurchaseItem
		purchaseItem.PurchaseId = id
		purchaseItem.ItemId = item.ItemId
		purchaseItem.Quantity = item.ItemQuantity

		err = utils.AddPurchaseItem(purchaseItem)
		if err != nil {
			tx.Rollback(context.Background())
			fmt.Printf("Error adding purchase items: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	err = utils.ClearCartItems(r.Header.Get("Authorization"))
	if err != nil {
		tx.Rollback(context.Background())
		fmt.Printf("Error adding purchase items: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	err = tx.Commit(context.Background())
	if err != nil {
		tx.Rollback(context.Background())
		fmt.Printf("Error commiting transaction to DB: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write([]byte("Purchase successfully created."))
}
