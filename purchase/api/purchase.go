package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/render"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/models"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/utils"
)

type PurchaseOrder struct {
	CustomerId int `json:"customer_id"`
	PaymentId  int `json:"payment_id"`
	Items      []models.PurchaseItem
}

func GetPurchases(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func GetPurchaseById(w http.ResponseWriter, r *http.Request) {
	var purchase models.Purchase

	id := r.URL.Query().Get("id")
	if id == "" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	err := utils.DB.QueryRow(context.Background(), "SELECT * FROM purchase WHERE id=$1",
		id).Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchase)
}

func GetPurchasesForUser(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase

	id := r.URL.Query().Get("id")
	if id == "" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase WHERE customer_id=$1")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func AddPruchase(w http.ResponseWriter, r *http.Request) {

	var purchase PurchaseOrder

	err := json.NewDecoder(r.Body).Decode(&purchase)
	// Validate that all the information required was sent to us
	if err != nil || purchase.CustomerId == 0 || purchase.PaymentId == 0 || len(purchase.Items) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	//TODO check user exists with userToken
	//TODO check payment exists --> Payment not yet implemented ignore for now

	var cost float32
	for _, _item := range purchase.Items {
		item, err := utils.FetchItem(_item.ItemId)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if item.Stock < _item.Quantity {
			//Not enough in stock
			// TODO add a way of conveying message
			w.WriteHeader(http.StatusBadRequest)
			return
		}
		//Add price to order and update stock
		cost += item.Price
		item, err = utils.OrderItem(_item.ItemId, _item.Quantity)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	// Add the purchase to the database
	// Vulnerabilities: SQL injection
	var query = fmt.Sprintf("INSERT INTO purchase(customer_id,payment_id,purchase_cost,purchase_date) VALUES ('%d','%d','%f','%s')",
		purchase.CustomerId, purchase.PaymentId, cost, time.Now())
	_, err = utils.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//TODO add all items to purchaseItem @/item/addPurchaseItem, if unsuccessful, cancel purchase
	for _, item := range purchase.Items {
		err = utils.AddPurchaseItem(item)
		if err != nil {
			fmt.Printf("Error adding purchase items: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	// if err != nil {
	// 	query = fmt.Sprintf("DELETE FROM purchase WHERE id=%s", purchase.Id)
	// 	_, err = utils.DB.Exec(context.Background(), query)
	// 	if err != nil {
	// 		fmt.Printf("Error when adding purchase items, purchase failed to cancel: %v\n", err)
	// 		w.WriteHeader(http.StatusInternalServerError)
	// 		return
	// 	}
	// 	fmt.Printf("Error when adding purchase items, purchase cancelled: %v\n", err)
	// 	w.WriteHeader(http.StatusInternalServerError)
	// 	return
	// }

	w.Write([]byte("Purchase successfully created."))
}
