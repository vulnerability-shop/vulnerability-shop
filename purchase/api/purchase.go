package api

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/go-chi/render"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/utils"
)

type Purchase struct {
	Id          	int    	`json:"id"`
	CustomerId		int 	`json:"customer_id"`
	PaymentId		int 	`json:"payment_id"`
	PurchaseCost	float 	`json:"purchase_cost"`
	PurchaseDate   	string	`json:"purchase_date"`
}

type PurchaseOrder struct {
	CustomerId		int 	`json:"customer_id"`
	PaymentId		int 	`json:"payment_id"`
	items			[]PurchaseItem
}

func getPurchases() ([]Purchase, error) {
	var purchases []Purchase

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase")
	if err != nil {
		return purchases, errors.New("failed retrieving purchase")
	}

	defer rows.Close()

	for rows.Next() {
		var purchase Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			return purchases, err
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		return purchases, err
	}

	return purchases, nil
}

func getPurchaseItemById(id int) (Purchase, error) {
	var purchase Purchase

	err := utils.DB.QueryRow(context.Background(), "SELECT * FROM purchase WHERE id=$1",
		strconv.Itoa(id)).Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
	if err != nil {
		return purchase, errors.New("failed retrieving purchase")
	}

	return purchase, nil
}

func getPurchasesForUser(id int) ([]Purchase, error) {
	var purchases []Purchase

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase WHERE customer_id=$1")
	if err != nil {
		return purchases, errors.New("failed retrieving purchases for user")
	}

	defer rows.Close()

	for rows.Next() {
		var purchase Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			return purchases, err
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		return purchases, err
	}

	return purchases, nil
}

func addPruchaseItem(w http.ResponseWriter, r *http.Request) {
	//Not implemented
	w.WriteHeader(http.StatusInternalServerError)
	return

	var purchase PurchaseOrder

	err := json.NewDecoder(r.Body).Decode(&purchase)
	// Validate that all the information required was sent to us
	if err != nil || len(purchase.CustomerId) == 0 || len(purchase.PaymentId) == 0 len(purchase.items) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	//TODO check user exists
	//TODO check payment exists --> Payment not yet implemented ignore for now
	//TODO calculate cost by fetching all items

	// Vulnerabilities: SQL injection
	query = fmt.Sprintf("INSERT INTO purchase(customer_id,payment_id,purchase_cost,purchase_date) VALUES ('%s','%s','%s','%s')",
	purchase.CustomerId, purchase.PaymentId, 0, time.Now())

	// Add the purchase to the database
	//TODO get id from added purchase
	_, err = utils.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//TODO add all items to purchaseItem @/item/addPurchaseItem, if unsuccessful, cancel purchase
	// if err != nil {
	// 	query = fmt.Sprintf("DELETE FROM purchase WHERE id=%s", purchase.Id)
	// 	_, err = utils.DB.Exec(context.Background(), query)
	// 	if err != nil {
	// 		fmt.Printf("Error when adding purchase items, purchase failed to cancel: %v\n", err)
	// 		w.WriteHeader(http.StatusInternalServerError)
	// 		return
	// 	}
	// 	fmt.Printf("Error when adding purchase items, purchase cancelled: %v\n", err)
	// 	w.WriteHeader(http.StatusInternalServerError)
	// 	return
	// }

	w.Write([]byte("Purchase successfully created."))
}
