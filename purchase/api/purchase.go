package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/render"
	"github.com/jackc/pgx/v5"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/models"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/utils"
)

type PurchaseOrder struct {
	CustomerId int `json:"customer_id"`
	PaymentId  int `json:"payment_id"`
	Items      []models.PurchaseItem
}

func GetPurchases(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func GetPurchaseById(w http.ResponseWriter, r *http.Request) {
	var purchase models.Purchase

	id := r.URL.Query().Get("id")
	if id == "" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	err := utils.DB.QueryRow(context.Background(), "SELECT * FROM purchase WHERE id=$1",
		id).Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchase)
}

func GetPurchasesForUser(w http.ResponseWriter, r *http.Request) {
	var purchases []models.Purchase
	var id int = r.Context().Value(utils.UserContext{}).(int)
	if id == -1 {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchase WHERE customer_id=$1")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	defer rows.Close()

	for rows.Next() {
		var purchase models.Purchase
		err = rows.Scan(&purchase.Id, &purchase.CustomerId, &purchase.PaymentId, &purchase.PurchaseCost, &purchase.PurchaseDate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte(err.Error()))
			return
		}
		purchases = append(purchases, purchase)
	}

	if rows.Err() != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	render.JSON(w, r, &purchases)
}

func AddPruchase(w http.ResponseWriter, r *http.Request) {
	var purchase PurchaseOrder
	var tx pgx.Tx
	var err error

	var userId int = r.Context().Value(utils.UserContext{}).(int)
	if userId == -1 {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	err = json.NewDecoder(r.Body).Decode(&purchase)
	purchase.CustomerId = userId
	// Validate that all the information required was sent to us
	if err != nil || purchase.PaymentId == 0 || len(purchase.Items) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	//TODO check payment exists --> Payment not yet implemented ignore for now

	//Begin transaction
	tx, err = utils.DB.BeginTx(context.Background(), pgx.TxOptions{})
	if err != nil {
		fmt.Printf("Error starting transaction: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	//Fetch items to calculate price and update inventory
	var cost float32
	for _, purchaseItem := range purchase.Items {
		item, err := utils.FetchItem(purchaseItem.ItemId)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if item.Id == 0 || purchaseItem.Quantity <= 0 {
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		if item.Stock < purchaseItem.Quantity {
			//Not enough in stock
			fmt.Print("Not enough stock")
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		//Add price to order and update stock
		cost += item.Price
		_, err = utils.OrderItem(purchaseItem.ItemId, purchaseItem.Quantity)
		if err != nil {
			tx.Rollback(context.Background())
			fmt.Printf("Error updating inventory: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	// Add the purchase to the database
	// Vulnerabilities: SQL injection
	var query = fmt.Sprintf("INSERT INTO purchase(customer_id,payment_id,purchase_cost,purchase_date) VALUES ('%d','%d','%f','%s') RETURNING id",
		purchase.CustomerId, purchase.PaymentId, cost, time.Now())
	// The Id of the created purchase
	var id int = 0
	err = utils.DB.QueryRow(context.Background(), query).Scan(&id)
	if err != nil {
		tx.Rollback(context.Background())
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Add all items to purchaseItem @/item/addPurchaseItem, if unsuccessful, cancel purchase
	for _, item := range purchase.Items {
		item.PurchaseId = id
		err = utils.AddPurchaseItem(item)
		if err != nil {
			tx.Rollback(context.Background())
			fmt.Printf("Error adding purchase items: %v\n", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
	}

	err = tx.Commit(context.Background())
	if err != nil {
		tx.Rollback(context.Background())
		fmt.Printf("Error commiting transaction to DB: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write([]byte("Purchase successfully created."))
}
