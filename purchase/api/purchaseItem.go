package api

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/go-chi/render"
	"github.com/vulnerability-shop/vulnerability-shop/purchase/utils"
)

type PurchaseItem struct {
	Id          int		`json:"id"`
	PurchaseId  int		`json:"purchase_id"`
	ItemId    	int		`json:"item_id"`
	Quantity    int		`json:"quantity"`
}

func getPurchaseItems() ([]PurchaseItem, error) {
	var items []PurchaseItem

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchaseitem")
	if err != nil {
		return items, errors.New("failed retrieving purchase item")
	}

	defer rows.Close()

	for rows.Next() {
		var item PurchaseItem
		err = rows.Scan(&item.Id, &item.PurchaseId, &item.ItemId, &item.Quantity)
		if err != nil {
			return items, err
		}
		items = append(items, item)
	}

	if rows.Err() != nil {
		return items, err
	}

	return items, nil
}

func getPurchaseItemById(id int) (PurchaseItem, error) {
	var item PurchaseItem

	err := utils.DB.QueryRow(context.Background(), "SELECT * FROM purchaseitem WHERE id=$1",
		strconv.Itoa(id)).Scan(&item.Id, &item.PurchaseId, &item.ItemId, &item.Quantity)
	if err != nil {
		return item, errors.New("failed retrieving purchase item")
	}

	return item, nil
}

func getPurchaseItemsForPurchase(id int) ([]PurchaseItem, error) {
	var items []PurchaseItem

	rows, err := utils.DB.Query(context.Background(), "SELECT * FROM purchaseitem WHERE purchase_id=$1")
	if err != nil {
		return items, errors.New("failed retrieving purchase item")
	}

	defer rows.Close()

	for rows.Next() {
		var item PurchaseItem
		err = rows.Scan(&item.Id, &item.PurchaseId, &item.ItemId, &item.Quantity)
		if err != nil {
			return items, err
		}
		items = append(items, item)
	}

	if rows.Err() != nil {
		return items, err
	}

	return items, nil
}

func addPurchaseItem(w http.ResponseWriter, r *http.Request) {
	var item PurchaseItem

	err := json.NewDecoder(r.Body).Decode(&item)
	// Validate that all the information required was sent to us
	if err != nil || len(item.purchase_id) == 0 || len(item.item_id) == 0 || len(item.quantity) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Vulnerability: SQL injection
	query := fmt.Sprintf("SELECT * FROM purchaseitem WHERE purchase_id='%s' AND item_id='%s'", item.purchase_id, item.item_id)

	// Query the database for any purchase that already contains the item/purchase pair
	rows, err := utils.DB.Query(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	defer rows.Close()

	// If we find any rows, the purchaseItem already exists
	if rows.Next() {
		w.WriteHeader(http.StatusConflict)
		w.Write([]byte("purchaseItem already exists."))
		return
	}

	// Vulnerabilities: SQL injection
	query = fmt.Sprintf("INSERT INTO purchaseitem (purchase_id,item_id,quantity) VALUES ('%s','%s','%s')",
	item.purchase_id, item.item_id, item.quantity)

	// Add the purchase item to the database
	_, err = utils.DB.Exec(context.Background(), query)
	if err != nil {
		fmt.Printf("Database query failed: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Write([]byte("PurchaseItem successfully created."))
}