package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/go-chi/chi/v5"
)

type services struct {
	listOfServices map[string][]service
	sync.RWMutex
}

type service struct {
	address string
	isAlive bool
}

func main() {
	s := services{make(map[string][]service), sync.RWMutex{}}
	r := chi.NewRouter()
	r.HandleFunc("/register", s.registerHandler)
	r.HandleFunc("/getAddress", s.getAddressHandler)
	r.HandleFunc("/unRegister", s.unRegisterHandler)
	go s.servicesPollingProcess()
	err := http.ListenAndServe(":4000", r)
	if err != nil {
		log.Println(err)
	}

}

func (s *services) registerHandler(w http.ResponseWriter, r *http.Request) {
	queryParams := r.URL.Query()
	w.WriteHeader(http.StatusOK)
	s.register(queryParams["key"][0], queryParams["address"][0])
}

func (s *services) unRegisterHandler(w http.ResponseWriter, r *http.Request) {
	queryParams := r.URL.Query()
	w.WriteHeader(http.StatusOK)
	s.unRegister(queryParams["key"][0], queryParams["address"][0])
}

func (s *services) getAddressHandler(w http.ResponseWriter, r *http.Request) {
	queryParams := r.URL.Query()
	w.Header().Set("Content-Type", "application/json")
	w.Write(s.getAddress(queryParams["key"][0]))
}

func (s *services) getAddress(key string) []byte {
	s.RLock()
	defer s.RUnlock()
	var activeService []string
	for _, service := range s.listOfServices[key] {
		if service.isAlive {
			activeService = append(activeService, service.address)
		}
	}
	urlsJson, _ := json.Marshal(activeService)
	return urlsJson
}

func (s *services) register(key string, address string) {
	s.Lock()
	defer s.Unlock()
	if s.listOfServices[key] != nil {
		for index, service := range s.listOfServices[key] {
			if service.address == address {
				s.listOfServices[key][index].isAlive = true
				return
			}
		}
		if _, ok := s.listOfServices[key]; ok {
			s.listOfServices[key] = append(s.listOfServices[key], service{address, true})
		} else {
			s.listOfServices[key] = []service{{address, true}}
		}
	} else {
		s.listOfServices[key] = []service{{address, true}}
	}

}

func (s *services) unRegister(key string, address string) {
	for index, service := range s.listOfServices[key] {
		if service.address == address {
			s.listOfServices[key][index].isAlive = false
			break
		}
	}
}

func (s *services) servicesPollingProcess() {
	for {
		s.Lock()
		for key, services := range s.listOfServices {
			for _, service := range services {
				if service.isAlive {
					s.Poll(key, service.address)
				}
			}
		}
		s.Unlock()
		time.Sleep(2 * time.Second)
	}
}

func (s *services) Poll(key string, service string) {
	resp, err := http.Get("" + service + "/api/health/ping")
	if err != nil {
		fmt.Println("http issue with" + service)
		return
	}
	if resp.StatusCode == http.StatusOK {
		fmt.Println("received 200")
	} else if resp.StatusCode == http.StatusInternalServerError {
		fmt.Println("received 500")
		s.unRegister(key, service)
		return
	} else {
		fmt.Println("received some other http code: ", resp.StatusCode)
		return
	}
}
